#summary i2c to UART gateway.
= WORK IN PROGRESS =
this article is not finalized yet. I am currently planning and making mistakes. When things are working, I will document the progress and notes here for later usage. feel free to use for your own usage as well.

= Introduction =

The idea is to create a i^2^c master device with ATtiny2313 which could be then commanded using hardware UART from a PC/MAC. This kind of debugging devices are already out there in the markets, but this should be relatively easy practice for everyone who are interested in the protocol itself and the 8-bit MCU's.

== What is ATtiny2313? ==
[http://upload.wikimedia.org/wikipedia/commons/thumb/8/86/ATtiny2313.png/240px-ATtiny2313.png][http://quickanddirty.googlecode.com/files/attiny2313.png]
[http://quickanddirty.googlecode.com/files/avr_isp.jpg] <br />
[http://www.atmel.com/dyn/resources/prod_documents/doc2543.PDF ATtiny2313] is a low power 8-bit microcontroller.
  * 2KB of In-System Self-Programmable Flash
  * 128 Bytes In-System Programmable EEPROM
  * 128 Bytes Internal SRAM
  * USI-Universal Serial Interface
  * Full Duplex UART. 

== What I^2^C stands for? ==
[http://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/I2C.svg/350px-I2C.svg.png]<br />

I^2^C is a multi-master serial single-ended computer bus invented by Philips that is used to attach low-speed peripherals to a motherboard, embedded system, or cellphone. Since the mid 1990s several competitors (e.g. Siemens AG (later Infineon Technologies AG), NEC, Texas Instruments, STMicroelectronics (formerly SGS-Thomson), Motorola (later Freescale), Intersil, etc.) brought I²C products on the market, which are fully compatible with the NXP (formerly Philips' semiconductor division) I²C-system. As of October 1, 2006, no licensing fees are required to implement the I²C protocol. However, fees are still required to obtain I²C slave addresses allocated by NXP
  * read more @ [http://en.wikipedia.org/wiki/I%C2%B2C wikipedia].
= UART =
*Always* use external oscillator for time critical tasks.
== UBRR register - setting baud rate ==
[http://quickanddirty.googlecode.com/files/avr-UBRR.png]
== Init 2400 8 n 1 / F_CPU 16MHz ==
{{{
#define BAUDMODE 416 //value from datasheet.
UBRRL = BAUDMODE;
UBRRH = (BAUDMODE >> 8);

// enable tx and rx
UCSRB =  (1<<TXEN) | (1<<RXEN);
}}}

= Details =

Checklist
  * Search and read Atmel Application Notes *check*
    * [http://atmel.com/dyn/resources/prod_documents/doc2561.pdf AVR310]: Using the USI module as a I2C master [http://atmel.com/dyn/resources/prod_documents/AVR310.zip src]
    * [http://atmel.com/dyn/resources/prod_documents/doc2547.pdf AVR244]: AVR UART as ANSI Terminal Interface [http://atmel.com/dyn/resources/prod_documents/AVR244.zip src]
    * [http://atmel.com/dyn/resources/prod_documents/doc2557.pdf AVR303]: SPI-UART Gateway [http://atmel.com/dyn/resources/prod_documents/AVR303.zip src]
  * Research the devices in the application notes *in progress*
  * Combine information from the application notes into a single black box device
  * add UART to USB chip for better usability
  * make a crossplatform UI for the hardware
    * make a commandline prototype with Python to validate the hardware functionality
    * make C++/Qt interface for the gateway.

= Notes for myself =
  * use external oscillator! the most vital part of the communication.. n00b.. For ATtiny2313 the related UART baud rate table is Table 57. Attach it here for future usage.
  * V-usb as UART to USB gateway, should run with ATtiny2313.

== the plan ==
*PC/MAC*  => (usb)  =>  *2313 with vusb*  => (uart) =>  *2313 with uart*

or

*PC/MAC*  => (usb)  =>  *ftdi U232R*  => (uart) =>  *2313 with uart*

= Existing products =
[http://code.google.com/p/the-bus-pirate/ BusPirate] is a really good product and which should be bought, but as i have several AVR 8-bit MCU's available I could make similar device using them, which would be then _free_ for me.